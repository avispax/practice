# DB 設計基本方針

- 前提知識として「[プログラマのための SQL : ジョー・セルコ](https://amzn.to/3x4O5ou)」の記載内容を参考にしているので、そちらを習熟ください。DB 屋のバイブルですし、読んで損はない。
- ただし、用語については実務での定番表現とし、以下で統一します。
  - 用語 : 「テーブル」「行」「列」「データ」。
    - 列を「属性」、データを「エンティティ」とは称さない。

## 目次

1. 前提
   1. 記載範囲
2. DB 環境
3. ER 図について
4. エンティティの抽出、定義について
5. 正規化方針
   1. 他の正規化
   2. 非正規化
   3. NoSQL について
6. 命名規則
   1. 命名規則 : テーブル
   2. 命名規則 : 列
7. 制約
   1. NOT NULL 制約
   2. 一意制約
   3. CHECK 制約
8. DB 運用
   1. バックアップ設計
   2. リカバリ設計
9. 他  
   1. 好ましくないやり方、バッドノウハウ、アンチパターン  
      1. 第1正規化未満
      2. ダブルミーニング
      3. 単一参照テーブル
      4. 水平分割をしない
      5. 垂直分割をしない
         1. 絞り込み用
         2. サマリテーブル
   2. グレーゾーン
      1. 代理キー
      2. 列待ちテーブル
      3. 行待ちテーブル
      4. アドホックな集計キー
      5. 多段ビュー

## 1. 前提

- 当資料は ANSI 3 層スキーマアーキテクチャ から、外部-概念-内部 の考えに即した資料とする。
- 当プロジェクトのデータベースは 「AWS RDS for Oracle」 を採用する。
  - AWS の利用により、内部スキーマに関してストレージやサイジング、冗長構成、物理配置などについては記載外とする。
- 外部スキーマ に関しては要件定義の範疇となり設計方針ではないため記載外とする。
- 概念スキーマ での エンティティ定義 に関連する内容は要件定義であるため詳細な記載を行わない。
- 以下で当資料での記載範囲を「★」で示す。

### 1.1. 記載範囲

- 概念スキーマ

  - エンティティの抽出
  - エンティティの定義
  - **★ 正規化**
  - **★ ER 図**

- 内部スキーマ
  - **★ テーブル定義**
  - **★ インデックス定義**
  - ハードウェアサイジング
  - ストレージの冗長構成
  - 物理配置

## 2. DB 環境

- RDB : AWS RDS for Oracle
- DB ツール : A5M2（自分だけで使う場合は任意。何らかの有料ツールなど、手に馴染むものを使用すればよい。例:osqledit など）

## 3. ER 図について

- DB ツール : A5M2 を利用して、ER 図を作成する。
  - ツールは IE 表記法で表される。
  - ER 図の作成手順に関しては以下を参照する。  
     [ER 図出力手順.xlsx](X:\クライアント\イトーヨーカ堂\IYNS\200_仕様変更\220_追加開発\0004114_新お届けシステム\01.要件定義\25.テーブル・コード\ER図出力手順.xlsx)

## 4. エンティティの抽出、定義について

- 要件定義として顧客やシステム利用者と確定すること。

## 5. 正規化

### 5.1. 正規化方針

- 第 3 正規化を基本とする。
  - 第 3 正規化により、冗長性を排除し、一貫性と効率性を高める。

- 各正規化の利用について、方針を以下とする。

- 第 1 正規化 : 許可しない
- 第 2 正規化 : パフォーマンスなどを考慮し、第2正規化までは許容する。
- 第 3 正規化 : 基本的にこちらを採用する。
- ボイス-コッド正規化（3.5） : そうなってしまうこともあるので OK。ただし可逆性に気をつけること。不可逆になってしまう場合は NG。
- 第 4 正規化 : 第 3 正規化を詰めていくと自然と第 4 になることもあるので許可。
- 第 5 正規化 : 潔癖症ならここまで行くこともあるが、そこまでしなくてよい。

### 5.2. 非正規化

- 抽出時に JOIN が必要なので、効率が悪くないですか？
  - なくはないです。ただし、DB 構成が真にボトルネックと計測できた場合にのみ、第 2 正規化などに戻しましょう。
- サマリなどの情報抽出のパフォーマンスは遅いですよね。

  - そうですね。サマリデータを列に追加して第 3 正規化を崩せば簡単に解決できます。

- 非正規化を行う際に気を付けること
  - 本当に DB 構成・正規化に依る事象ですか。
    - 回線状況、周辺のコード、DB チューニング（インデックス、統計情報）、DB サイジングなど、全てを疑いましょう。
    - 数値ベースで判断しましょう。
      - ちなみに三井住友信託銀行プロジェクトでは第 3 正規化をやめ、第 2 正規化を採用しました w
  - 重複データの操作に漏れがないか
    - 第 2 正規化に戻す場合、データが重複するので、更新時のデータ整合性などに気を付けること。
  - 重複データの更新頻度は適切か
    - リアルタイムで更新か、バッチにより担保か、など。
  - DB 改修コストに見合うか
    - DB 構成が変わるとコードからなにから変わりますので、なんとなくでは直せません。上で書いたように「DB 構成がボトルネック」であれば改修やむなしですが、本当ですか？ 今どきの DB は遅くないですよ。

### 5.3. NoSQL について

- 当プロジェクトでは採用しないとのことで、記載外。

## 6. 命名規則

### 6.1. テーブル命名規則

- 弥谷さん策定中

## 6.2. フィールド命名規則

- 弥谷さん策定中

## 7. 制約

- 各制約は適切に設定する。

### 7.1. NOT NULL 制約

- 可能な限り付与する。
  - 語り始めたらキリがないですが、NULL は色々な厄介事を引き起こします。

### 7.2. 一意制約

- 特になし。一意性がある場合に適切に設定する。

### 7.3. CHECK 制約

- 可能な限り付与する。
  - 例えば年齢項目に 0 ～ 120 の上下限など。
  - 要件定義で確定しているはずなので適宜設定する。

## 8. DB 運用

### 8.1. バックアップ設計

- 記載外

### 8.2. リカバリ設計

- 記載外

## 9. 他

### 9.1. 好ましくないやり方。バッドノウハウ、アンチパターン

以下のケースは当プロジェクトでは禁止とします。

#### 9.1.1. 第 1 正規化未満（非スカラ値）

- なんかグチャグチャのデータ構成になっている。
- 悪い例  
   |id|社員名|家族|
  |:--|:--|:--|
  |001|山田太郎|花子|
  |002|佐藤一郎||
  |003|高橋|シロ<br>クロ|

- 表形式ではあるけど、リレーショナルでもないしデータとしても NG。  
   社員と家族をテーブル単位で分割し、ちゃんと作ろう。

- 対応案として、9.2.2. 列待ちテーブル、9.2.3. 行待ちテーブルを参照。

#### 9.1.2. ダブルミーニング

- 列の内容が便利に使われすぎている。

- 悪い例
  |id|名|身長|他|
  |:--|:--|:--|:--|
  |001|山田|170|体重 65|
  |002|佐藤|180|体重 73|
  |003|高橋|150|年齢 22|
- 修正案
  |id|名|身長|体重|年齢|
  |:--|:--|:--|:--|:--|
  |001|山田|170|65||
  |002|佐藤|180|73||
  |003|高橋|150||22|

- 意味のある列を用意し、適切に設定すること。

#### 9.1.3. 単一参照テーブル

- 上のバリエーション。あらゆるものをうまいこと入れているようなテーブル。

- 悪い例  
   |コード|AttrType|AttrValue|
  |:--|:--|:--|
  |001|名前|山田太郎|
  |001|身長|180|
  |002|国コード|01|
  |003|メルマガ|送る|

- 適切にテーブル化する。人の情報、国の情報、など。
  - データ型などもグチャグチャになりエラーに気付きにくい
  - パフォーマンスも良くない

- 行待ちテーブルとして正しい塊として取り扱う場合は問題ない。（関連 : 9.2.3. 行待ちテーブル）  
  あくまでも、雑多なテーブルになっていることが問題。

#### 9.1.4. 水平分割をしない

- 例えば、年度ごとのテーブルが存在する。DWH などでたまに見る。
- 年度ごとに n 万件の受注データが存在すると、全部まとまったテーブルだと全件ナメてしまうのでパフォーマンスが落ちたためこの形式にした、という経緯がある。

- 悪い例

  - table1 : 2001 年受注  
     |年度|会社 CD|売上（億円）|
    |:--|:--|:--|
    |2001|C001|36|
    |2001|C002|534|
    |2001|C003|2|
  - table2 : 2002 年受注  
     |年度|会社 CD|売上（億円）|
    |:--|:--|:--|
    |2002|C001|36|
    |2002|C003|5|
    |2002|C004|14|

- 修正案
  - その 1 : テーブルは統合していい。何件存在しても。
    |年度|会社 CD|売上（億円）|
    |:--|:--|:--|
    |2001|C001|36|
    |2001|C002|534|
    |2001|C003|2|
    |2002|C001|36|
    |2002|C003|5|
    |2002|C004|14|
  - その 2 : 今どきの DBMS なので（当プロジェクトでは Oracle）「[パーティション](https://www.oracle.com/technetwork/jp/ondemand/database/db-technique/d-12-disk-1484778-ja.pdf)」機能を使用する。

#### 9.1.5. 垂直分割をしない

- SELECT \* の結果が多すぎてパフォーマンスが問題になり、分割するときが多いときの対応法。
- 絞り込み用と、集計用に分類できる。

##### 9.1.5.1. 絞り込み用

- 例えば社員情報テーブルがなぜか 2 つあるような状況。
- 参照される列に偏りがあるため、よく参照される列を集めてそれ以外を分割したとう経緯が生まれる。

- 悪い例

  - table1 : 社員 1  
     |社員 ID|名前|年齢|
    |:--|:--|:--|
    |001|田中|36|
    |002|山田|34|
    |031|高橋|22|
  - table2 : 2002 年受注  
     |社員 ID|部署|血液型|
    |:--|:--|:--|
    |001|経理|A|
    |002|開発|A|
    |031|営業|B|

- 修正案
  - その 1 : データマート（DWH 分野の用語）を用意する。重複するけどそれのみを切り出した感じのやつ。
    - table1 : テーブルには全部の情報を入れる。
      |社員 ID|名前|年齢|部署|血液型|
      |:--|:--|:--|:--|:--|
      |001|田中|36|経理|A|
      |002|山田|34|開発|A|
      |031|高橋|22|営業|B|
    - table2 : よく参照される列のみで別のテーブルを作成する。
      |社員 ID|名前|年齢|
      |:--|:--|:--|
      |001|田中|36|
      |002|山田|34|
      |031|高橋|22|
    - データ同期頻度は要件確定する。

##### 9.1.5.2. サマリテーブル

- 分割理由が算出用の場合、予め算出した情報を格納するテーブルを別途用意する。
- 悪い例

  - table1 : テーブルには全部の情報を入れる。
    |社員 ID|名前|年齢|部署|血液型|
    |:--|:--|:--|:--|:--|
    |001|田中|36|経理|A|
    |002|山田|34|開発|A|
    |031|高橋|22|営業|B|

- 修正案
  - その 1 : サマリテーブル
    - table1 : テーブルには全部の情報を入れる。
      |社員 ID|名前|年齢|部署|血液型|
      |:--|:--|:--|:--|:--|
      |001|田中|36|経理|A|
      |002|山田|34|開発|A|
      |031|高橋|22|営業|B|
    - table2 : よく参照される列のみで別のテーブルを作成する。
      |部署|平均年齢|
      |:--|:--|
      |経理|42|
      |開発|35|
      |営業|32|
    - データ同期頻度は要件確定する。

### 9.2. グレーゾーン

基本的に NG だが、キレイ事ばかりではうまく行かないとき、これらは上長承認のもと許容される。  
\*9.1.は NG

#### 9.2.1. 代理キー（）

- 状況 : 主キーがよくわからない状況になっている。  
   以下、よくある状況。

  - IF 連携される他システムのデータで、なぜか一意になるキー項目がない
    - table : 外部 IF からのなにか
      |どこかのIF|名前|年齢|部署|血液型|
      |:--|:--|:--|:--|:--|
      |001|田中|36|経理|A|
      |002|山田|34|開発|A|
      |001|高橋|22|営業|B|
  - キーが再帰的に使い回されている
  - キーはあるが途中で指す内容が変更となって使い回された。  
     例:会社の部署の統廃合で総務部が広報部を吸収する感じで合併し、広報部がキーごと消滅した、など。

- 対応案 1 : テーブルを変更してもいい場合

  - 自前の ID 列を用意し、そちらでちゃんとした ID 形態の列などを用意して使用する。

    - table : 外部 IF からのなにか
      |あっちの列|**自前の ID**|名前|年齢|部署|血液型|
      |:--|:--|:--|:--|:--|:--|
      |001|**000001**|田中|36|経理|A|
      |002|**000002**|山田|34|開発|A|
      |001|**000003**|高橋|22|営業|B|

  - ID 列は DBMS のシーケンスオブジェクトを使用する。オラクルには標準搭載。
    ```SQL
        CREATE SEQUENCE my_seq
        START WITH 1
        INCREMENT BY 1
        NOCYCLE;
    ```

- 対応案 2 : 勝手にテーブルをいじれない場合

  - 日付情報テーブルが存在する場合、タイムスタンプ、インターバルとして使用する。
  - 代理キーとの違いとして、代理キーはただの連番となるが、年度情報や入荷情報などは業務的に意味がある自然キーなどで一意に利用できる可能性が高い。

- 余談 : キー項目を Java のコードなどで生成して INSERT 文に入れちゃえば？
  - その考え方ならそもそも DBMS 使う必要ないじゃん。

#### 9.2.2. 列待ちテーブル

- 9.1.1. 第 1 正規化未満 は このように対応可能。
- 悪い例  
   |id|社員名|家族|
  |:--|:--|:--|
  |001|山田太郎|花子|
  |002|佐藤一郎||
  |003|高橋|シロ<br>クロ|

- 対応案
  |id|社員名|家族 1|家族 2|家族 3|
  |:--|:--|:--|:--|:--|
  |001|山田太郎|花子|||
  |002|佐藤一郎||||
  |003|高橋|シロ|クロ||

- ただし基本は ↓ の行待ちテーブルとするほうが無難

#### 9.2.3. 行待ちテーブル

- 列待ちテーブル  
   |id|社員名|家族|
  |:--|:--|:--|
  |001|山田太郎|花子|
  |002|佐藤一郎||
  |003|高橋|シロ<br>クロ|

- 対応案 : 行街テーブル
  |id|家族|
  |:--|:--|
  |001|花子|
  |003|シロ|
  |003|クロ|

#### 9.2.4. アドホックな集計キー

- あとになってその場で追加されたような謎のキー項目が存在する。

  - 基本しか知らないお客さんが「ちょっと 1 列追加したらできるでしょ」みたいな言い方でよく追加される。
    - table : 社員マスタになぜか出身地方の ID が追加された。もともと出身県は ID として存在した。  
       |ID|名前|年齢|部署|血液型|出身県 ID|地方 ID|
      |:--|:--|:--|:--|:--|:--|:--|
      |001|田中|36|経理|A|01（北海道）|01（北海道、東北）|
      |002|山田|34|開発|A|02（青森）|01（北海道、東北）|
      |003|高橋|22|営業|B|40（福岡）|05（九州、沖縄）|
      |004|佐藤|45|経理|C|15（東京）|03（関東）|
      |005|吉田|50|営業|B|46（鹿児島）|05（九州、沖縄）|

- 対応案 1 : 正攻法。別テーブルで管理して、社員マスタに地方 ID とか入れない。
  |出身県 ID|地方 ID|
  |:--|:--|
  |01（北海道）|01（北海道、東北）|
  |02（青森）|01（北海道、東北）|
  |40（福岡）|05（九州、沖縄）|
  |15（東京）|03（関東）|
  |46（鹿児島）|05（九州、沖縄）|

- 対応案 2 : ビュー機能を使う。

  - DB そのものは変更しないが DBMS は触る。  
     ただし多段ビュー（9.2.5.）には注意すること。

- 対応案 3 : GROUP BY を工夫する。
  - SQL コードのみで対応可能。
    ```SQL
    SELECT CASE WHEN 出身県ID IN ('01', '02', '03'...) THEN '01'
                WHEN 出身県ID IN ('10', '11', '12'...) THEN '03'
                WHEN 出身県ID IN ('40', '41', '42'...) THEN '05'
    FROM 都道府県
    GROUP BY CASE WHEN 出身県ID IN ('01', '02', '03'...) THEN '01'
                WHEN 出身県ID IN ('10', '11', '12'...) THEN '03'
                WHEN 出身県ID IN ('40', '41', '42'...) THEN '05'
                ELSE NULL END;
    ```

#### 9.2.5. 多段ビュー

- ビューは実データを毎回 SELECT するので、SELECT 階層が深くなると悪影響が大きいので注意すること。
  - パフォーマンスが悪くなる。
  - 基底データがなにか追跡しづらくなる。
  - 基底データが妥当なのかどうか、判断しづらくなる → メンテナンス性の低下。
